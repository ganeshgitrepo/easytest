<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Easytest : EasyTest is an extension to JUnit to provide easy data driven testing framework to its users." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Easytest</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/EaseTech/easytest">View on GitHub</a>

          <h1 id="project_title">Easytest</h1>
          <h2 id="project_tagline">EasyTest is an extension to JUnit to provide easy data driven testing framework to its users.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/EaseTech/easytest/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/EaseTech/easytest/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>EasyTest : A Data Driven Testing approach to JUnit</h2>

<p>An extension of JUnit to perform Data Driven Testing using annotations.</p>

<h2>Introduction:</h2>

<p>This project is built as an extension of Junit, and has taken the approach of providing test data to the test classes/methods at the whole new level. 
to how the test data is provided to the test method by the JUnit Runner.</p>

<p>Before describing the changes proposed in this repository, let us walk through what JUnit provides us for performing Data Driven Testing.
JUnit, in its experimental package provides us two options:</p>

<p>1) Parameterized Runner, in which we provide test data to the test method with <a href="https://github.com/parameters" class="user-mention">@parameters</a> annotation</p>

<p>2) Theories Runner, in which we provide test data to the test method using either @DataPpoint(s) annotations 
or by using @ParametersSuppliedBy and DataSupplier extension.</p>

<p>Both of the above approach requires the user to write boilerplate code in their test classes. Even though the data now resides outside the test case,
it still is coupled with the test class. Finally, the ease of use that JUnit has been synonymous with for so long appears to be missing in the above experimental Runners.</p>

<p>You can find the detailed examples of Parameterized Runner and its limitations here:
<a href="http://www.kumaranuj.com/2012/08/junits-parameterized-runner-and-data.html">http://www.kumaranuj.com/2012/08/junits-parameterized-runner-and-data.html</a></p>

<p>and for Theories runner here :
<a href="http://www.kumaranuj.com/2012/08/junit-theories-and-data-driven-testing.html">http://www.kumaranuj.com/2012/08/junit-theories-and-data-driven-testing.html</a></p>

<p>All this and more, inspired me to write a test framework that is simple to use, is flexible in its approach and can be extended by the user in a consistent manner.
Finally I wanted to bring back the same ease of use to the testing world, like we had few years ago(annotate methods with <a href="https://github.com/test" class="user-mention">@test</a> and relax).</p>

<h2>What this code base consists of:</h2>

<p>This code base consists of :</p>

<p>1) A customized JUnit Runner that gives its user ability to provide test data in a consistent and user controlled manner. It is called DataDrivenTest. 
This Runner works on our favorite annotation <a href="https://github.com/test" class="user-mention">@test</a> from JUnit and also supports passing parameters to the test method. And this is not its only selling point.</p>

<p>2) DataDrivenTest runner gives its users the ability to inspect the testMethod and its associated test data in the IDE. 
For example, when a user runs the test method with name : getTestData with the following test data:</p>

<p><b> "libraryId=1 and itemId=2"</b></p>

<p><b> "libraryId=2456 and itemId=789"</b></p>

<p>then, DataDrivenTest, will provide the details of the executing test method in the JUnit supported IDEs like this: </p>

<p><b>getTestData{libraryId=1 ,itemId=2}</b></p>

<p><b>getTestData{libraryId=2456 ,itemId=789}</b></p>

<p>NOTE: In case the user has simple test methods(without parameters), DataDrivenTest runner supports that implicitly.</p>

<p>3) A Data Loading Strategy consisting of interface Loader and classes LoaderFactory and CSVDataLoader and an Enum LoaderType. 
EasyTest supports four different ways for the user to load Data:</p>

<ul>
<li>CSV</li>
<li>XECEL</li>
<li>XML</li>
<li>
<p>CUSTOM</p>

<p>CSV, EXCE,XML data loader implementation is already available and the users can use it out of the box.
To give an example of the design, CSVDataLoader is an implementation of Loader interface and provides a mechanism to load test data from a CSV file.
LoaderFactory is a Factory class that is responsible for returning the right type of Loader based on the loaderType.</p>
</li>
</ul><p>3) Param annotation that is an extension of ParametersSuppliedBy annotation and provides a lot of useful features to its user. Some of them include:</p>

<ul>
<li><p>A mechanism to provide custom Objects to the test method. For eg. if a test method requires a user defined object LibraryId, then the Param annotation 
can automatically convert the string data(provided in the CSV file) to the LibraryId Object.This is based on Java RegistryEditorsSupport. In case the standard PropertyEditor find mechanism does not apply to your project, 
you can always register your own custom editors in your test class and the Framework will take care of the rest. For example look in the test package at LibraryId and LibraryIdEditor.</p></li>
<li><p>Another way to provide custom objects to the test method is by using ConverterManager and AbstractConverter. 
A user can provide its own implementation of converting a Map (containing the key value pair) to an object that is expected by the test method and the extension framework will take care of the rest.
See <b>CASE 4 </b>below </p></li>
</ul><p>4) DataLoader annotation to be used by the user in the test to provide information about the test data like:</p>

<ul>
<li><p>The list of files from which to load the input test data. This is a OPTIONAL field whose type is a String[]</p></li>
<li><p>The type of loader to load the files, identified by loaderType.</p></li>
<li>
<p>The custom loader that is used by users to provide custom data loaders. It is an OPTIONAL field. </p>

<p>DataLoader annotation can be used both at the class level as well as at the method level.
In case the annotation is applied at both places, then method level takes precedence over Class level.</p>

<p>Currently the framework supports CSV , XML, Excel and Custom loader Type.</p>
</li>
</ul><p>5)DataContext class that contains thread-local variables that stores test data as well as the name of the currently executing test method.</p>

<p>6)Finally, EasyTest also supports DataPoint, DataPoints and ParameterSuppliedBy annotations as well.</p>

<h2>Some Examples of using EasyTest</h2>

<p><b>CASE 1</b>: Provides input test data in the form of CSV file at the class level, that is used by the test methods.</p>

<pre><code>@RunWith(DataDrivenTest.class)
@DataLoader(filePaths = { "getItemsData.csv" }, loaderType = LoaderType.CSV)
public class TestConditionsSupportedByEasyTestRunner {


/**
 * A Simple test that uses data provided by TestData annotation present at the Class level
 * @param inputData a generic map of input test data that contains all the required parameters for the test data.
 */
@Test
public void testGetItems(@Param()
Map&lt;String, String&gt; inputData) {
    System.out.println("library Id : " + inputData.get("LibraryId") + " and item type : "
        + inputData.get("itemType") + " and search text array :" + inputData.get("searchText"));

}
</code></pre>

<p><b>CASE 2</b>: User provides input test data in the form of EXCEL file at the method level only.</p>

<pre><code>@RunWith(DataDrivenTest.class)
public class TestConditionsSupportedByEasyTestRunner {


/**
 * A Simple test that uses data provided by TestData annotation present at the Method level
 * @param inputData a generic map of input test data that contains all the required parameters for the test data.
 */
@Test
@DataLoader(filePaths = { "getItemsData.xls" }, loaderType = LoaderType.EXCEL)
public void testGetItems(@Param()
Map&lt;String, String&gt; inputData) {
    System.out.println("library Id : " + inputData.get("LibraryId") + " and item type : "
        + inputData.get("itemType") + " and search text array :" + inputData.get("searchText"));

}
</code></pre>

<p><b>CASE 3</b>: User provides input test data in the form of XML file at the Class level and as CSV file at method level. In this case method level test data takes priority over class level test data.</p>

<pre><code>@RunWith(DataDrivenTest.class)
@DataLoader(filePaths = { "getItemsData.xml" }, loaderType = LoaderType.XML)
public class TestConditionsSupportedByEasyTestRunner {


/**
 * A Simple test that uses data provided by TestData annotation present at the Method level
 * @param inputData a generic map of input test data that contains all the required parameters for the test data.
 */
@Test
@DataLoader(filePaths = { "getCustomData.csv" }, loaderType = LoaderType.CSV)
public void testGetItems(@Param()
Map&lt;String, String&gt; inputData) {
    System.out.println("library Id : " + inputData.get("LibraryId") + " and item type : "
        + inputData.get("itemType") + " and search text array :" + inputData.get("searchText"));

}
</code></pre>

<p><b>CASE 5</b>: User can also use their custom defined Objects as parameters in the test case. In this case LibraryId and ItenmId will be resolved using RegsitryEditorSupport of java:</p>

<pre><code>@RunWith(DataDrivenTest.class)
@DataLoader(filePaths = { "getItemsData.csv" }, loaderType = LoaderType.CSV)
public class TestConditionsSupportedByEasyTestRunner {


/**
 * A Simple test that uses data provided by TestData annotation present at the Method level
 * @param inputData a generic map of input test data that contains all the required parameters for the test data.
 */
@Test
@DataLoader(loader = MyDataLoader.class, loaderType = LoaderType.CUSTOM)
public void testGetItems(@Param()
LibraryId id , @Param(name="itemid") ItemId itemId) {
    System.out.println("library Id : " + id.getValue() + " and item type : "
        + itemId.getValue());
        # Param annotation tells the framework that the parameter's value should be provided by the framework.
           It can also take an optional name attribute which gives more control over the data to the user.

}
</code></pre>

<p><b>CASE 6</b>: User can also use their custom defined objects when RegistryEditor support is not enough. The user simply has to either extend AbstractConverter class or implement the Converter interface and register it with the framework using ConverterManager class.</p>

<pre><code>@Test
@DataLoader(filePaths = { "getItemsData.csv" })
public void testConverter(@Param() Item item){
    Assert.assertNotNull(item);
    System.out.println(item.getDescription() + item.getItemId() + item.getItemType());

}

And the framework supports much much more like DataPOint, DataPOints, ParameterSuppliedBy etc. Look at the Getting Started Guide for more information.
</code></pre>

<h2>Conclusion</h2>

<p>This extension to JUnit focuses on bringing back the simplicity back to JUnit in JUnit way.
This extension also focuses mainly on performing Data Driven Testing within your system with ease and at the same time giving Flexibility and Extensibility to the user to use their custom behavior.
This extension is meant for people who want to write Test cases once and then reuse them again and again.
A single test can act both as a Unit Test and an integration test. Nothing in the test case should or will change. Only the test data and the tesSubject will change. This saves a lot of developers time and in turn of the project.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Easytest maintained by <a href="https://github.com/EaseTech">EaseTech</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
